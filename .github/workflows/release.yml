name: Release

on:
  push:
    tags:
      - "v*"
      - "[0-9]+.[0-9]+.[0-9]+*"

permissions:
  contents: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  CARGO_TERM_COLOR: always

jobs:
  build:
    name: Build ${{ matrix.target }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            archive: tar.gz

          - os: ubuntu-latest
            target: x86_64-unknown-linux-musl
            archive: tar.gz

          - os: macos-latest
            target: aarch64-apple-darwin
            archive: tar.gz

          - os: windows-latest
            target: x86_64-pc-windows-msvc
            archive: zip

    runs-on: ${{ matrix.os }}
    timeout-minutes: 45

    steps:
      - uses: actions/checkout@v4

      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - uses: Swatinem/rust-cache@v2
        with:
          shared-key: release-${{ matrix.target }}

      - name: Install musl tools
        if: matrix.target == 'x86_64-unknown-linux-musl'
        run: sudo apt-get update && sudo apt-get install -y musl-tools

      - name: Install Linux dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y libxcb-shape0-dev libxcb-xfixes0-dev

      - name: Import Apple certificate
        if: runner.os == 'macOS'
        env:
          CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          set -euo pipefail

          # Skip if no certificate configured
          if [ -z "${CERTIFICATE:-}" ]; then
            echo "::warning::No APPLE_CERTIFICATE secret configured, skipping code signing"
            echo "SIGNING_ENABLED=false" >> $GITHUB_ENV
            exit 0
          fi

          KEYCHAIN_PATH=$RUNNER_TEMP/signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
          CERT_PATH=$RUNNER_TEMP/certificate.p12

          # Create and configure keychain
          echo "Creating temporary keychain..."
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 900 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import certificate
          echo "Importing certificate..."
          echo "$CERTIFICATE" | base64 --decode > "$CERT_PATH"

          if ! security import "$CERT_PATH" \
            -P "$CERTIFICATE_PASSWORD" \
            -A -t cert -f pkcs12 \
            -k "$KEYCHAIN_PATH"; then
            echo "::error::Failed to import certificate"
            rm -f "$CERT_PATH"
            exit 1
          fi

          # Immediately delete the certificate file
          rm -f "$CERT_PATH"

          # Configure for codesign
          security list-keychain -d user -s "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple:,codesign: \
            -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Verify certificate is available
          echo "Available signing identities:"
          security find-identity -v -p codesigning "$KEYCHAIN_PATH"

          # Export for subsequent steps
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
          echo "SIGNING_ENABLED=true" >> $GITHUB_ENV

      - name: Build release binary
        run: cargo build --release --locked --target ${{ matrix.target }}

      - name: Sign macOS binaries
        if: runner.os == 'macOS' && env.SIGNING_ENABLED == 'true'
        env:
          KEYCHAIN_PATH: ${{ env.KEYCHAIN_PATH }}
        run: |
          set -euo pipefail

          echo "Keychain path: $KEYCHAIN_PATH"

          # List all available identities for debugging
          echo "=== All available signing identities ==="
          security find-identity -v -p codesigning "$KEYCHAIN_PATH" || true

          # Find signing identity
          IDENTITY=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | \
            grep "Developer ID Application" | head -1 | awk -F '"' '{print $2}')

          if [ -z "$IDENTITY" ]; then
            echo "::error::No Developer ID Application certificate found"
            echo "Make sure you exported a 'Developer ID Application' certificate, not an Apple Development or other type."
            exit 1
          fi

          echo "Using identity: $IDENTITY"

          # Sign binary with retry for timestamp server failures
          BINARY_PATH="target/${{ matrix.target }}/release/catboard"
          ATTEMPT=1
          MAX_ATTEMPTS=3
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "Signing attempt $ATTEMPT of $MAX_ATTEMPTS..."
            if codesign --force --deep --options runtime \
              --sign "$IDENTITY" \
              --timestamp \
              "$BINARY_PATH"; then
              echo "Binary signing succeeded"
              break
            else
              if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
                echo "::error::Signing failed after $MAX_ATTEMPTS attempts"
                exit 1
              fi
              echo "Retry in 5 seconds..."
              sleep 5
              ATTEMPT=$((ATTEMPT + 1))
            fi
          done

          # Sign Quick Action workflow
          echo "Signing Quick Action workflow..."
          codesign --force --deep \
            --sign "$IDENTITY" \
            --timestamp \
            "macos/Copy to Clipboard.workflow"

          # Verify signatures
          echo "=== Verifying binary signature ==="
          codesign --verify --deep --strict --verbose=4 "$BINARY_PATH"

          echo "=== Verifying Quick Action signature ==="
          codesign --verify --deep --strict --verbose=4 "macos/Copy to Clipboard.workflow"

          # Display signature info
          echo "=== Binary signature details ==="
          codesign --display --verbose=4 "$BINARY_PATH"

          # Test Gatekeeper (may fail without notarization)
          echo "=== Gatekeeper assessment ==="
          spctl --assess --type execute --verbose=4 "$BINARY_PATH" || \
            echo "::warning::Gatekeeper check failed (notarization may be required for full compliance)"

      - name: Notarize macOS binary
        if: runner.os == 'macOS' && env.SIGNING_ENABLED == 'true'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          set -euo pipefail

          # Skip if notarization credentials not configured
          if [ -z "${APPLE_ID:-}" ] || [ -z "${APPLE_ID_PASSWORD:-}" ]; then
            echo "::notice::Notarization skipped - APPLE_ID or APPLE_ID_PASSWORD not configured"
            exit 0
          fi

          BINARY_PATH="target/${{ matrix.target }}/release/catboard"

          # Create ZIP for notarization
          echo "Creating ZIP for notarization..."
          ditto -c -k "$BINARY_PATH" catboard.zip

          # Submit and wait
          echo "Submitting for notarization..."
          xcrun notarytool submit catboard.zip \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_ID_PASSWORD" \
            --team-id "$TEAM_ID" \
            --wait \
            --timeout 30m

          # Staple (optional for CLI binaries, may not be supported)
          echo "Attempting to staple..."
          xcrun stapler staple "$BINARY_PATH" || \
            echo "::notice::Stapling not supported for this binary type (this is normal for CLI tools)"

          rm -f catboard.zip

          # Note: We skip the final spctl verification because:
          # 1. CLI binaries can't be stapled (only .app bundles)
          # 2. Without stapling, spctl will always report "Unnotarized Developer ID"
          # 3. The notarization WAS accepted by Apple (see above)
          # 4. Gatekeeper will verify the notarization online when users run the binary
          echo "::notice::Notarization complete. Binary will pass Gatekeeper (verified online)."

      - name: Package (Unix)
        if: runner.os != 'Windows'
        run: |
          VERSION=${GITHUB_REF#refs/tags/}
          ARCHIVE_NAME="catboard-${VERSION}-${{ matrix.target }}"
          mkdir -p "${ARCHIVE_NAME}"
          cp "target/${{ matrix.target }}/release/catboard" "${ARCHIVE_NAME}/"
          cp README.md LICENSE "${ARCHIVE_NAME}/"

          # Include Quick Action for macOS
          if [ "${{ runner.os }}" == "macOS" ]; then
            cp -r "macos/Copy to Clipboard.workflow" "${ARCHIVE_NAME}/"
            echo "# macOS Installation" > "${ARCHIVE_NAME}/INSTALL_MACOS.md"
            echo "" >> "${ARCHIVE_NAME}/INSTALL_MACOS.md"
            echo "1. sudo cp catboard /usr/local/bin/" >> "${ARCHIVE_NAME}/INSTALL_MACOS.md"
            echo "2. cp -r Copy\ to\ Clipboard.workflow ~/Library/Services/" >> "${ARCHIVE_NAME}/INSTALL_MACOS.md"
            echo "3. Right-click any file in Finder to see Copy to Clipboard option." >> "${ARCHIVE_NAME}/INSTALL_MACOS.md"
          fi

          tar czf "${ARCHIVE_NAME}.tar.gz" "${ARCHIVE_NAME}"
          echo "ARCHIVE_NAME=${ARCHIVE_NAME}.tar.gz" >> $GITHUB_ENV

      - name: Package (Windows)
        if: runner.os == 'Windows'
        shell: bash
        run: |
          VERSION=${GITHUB_REF#refs/tags/}
          ARCHIVE_NAME="catboard-${VERSION}-${{ matrix.target }}"
          mkdir -p "${ARCHIVE_NAME}"
          cp "target/${{ matrix.target }}/release/catboard.exe" "${ARCHIVE_NAME}/"
          cp README.md LICENSE "${ARCHIVE_NAME}/"
          7z a "${ARCHIVE_NAME}.zip" "${ARCHIVE_NAME}"
          echo "ARCHIVE_NAME=${ARCHIVE_NAME}.zip" >> $GITHUB_ENV

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: catboard-${{ matrix.target }}
          path: ${{ env.ARCHIVE_NAME }}
          retention-days: 1

      - name: Clean up keychain
        if: runner.os == 'macOS' && always()
        run: |
          KEYCHAIN_PATH="${KEYCHAIN_PATH:-$RUNNER_TEMP/signing.keychain-db}"

          # Delete keychain if it exists
          if [ -f "$KEYCHAIN_PATH" ]; then
            security delete-keychain "$KEYCHAIN_PATH" 2>/dev/null || \
              echo "::warning::Failed to delete keychain"
          fi

          # Clean up any leftover certificate files
          rm -f $RUNNER_TEMP/certificate.p12 2>/dev/null || true

          # Reset to default keychain
          security list-keychains -d user -s login.keychain 2>/dev/null || true

  release:
    name: Create Release
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Prepare release files
        run: |
          mkdir -p release
          find artifacts -type f \( -name "*.tar.gz" -o -name "*.zip" \) -exec mv {} release/ \;
          cd release
          sha256sum * > checksums.txt
          cat checksums.txt

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: release/*
          draft: false
          prerelease: ${{ contains(github.ref, 'beta') || contains(github.ref, 'alpha') || contains(github.ref, 'rc') }}
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
